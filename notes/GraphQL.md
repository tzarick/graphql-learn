Parent: [[040 Knowledge Store MOC]]

## High-Level Intro

GraphQL is a specification typically used for remote client-server communications
- agnostic to the data source used
- agnostic to transport layer (but still most often used with HTTP)
- specifies how you can exchange info between client and server
- middle layer

GraphQL is an API standard
- enables declarative data fetching
	- a client can specify exactly what data it needs from an API
- GraphQL server exposes single endpoint and responds to queries (instead of multiple endpoints that return fixed data structures)

A query language for APIs
A more efficient alternative to REST
- increased mobile usage creates need for efficient data loading
- variety of different frontend frameworks and platforms on the client-side
- Fast dev speed and expectation for rapid feature development

GraphQL can be used with any programming language and framework
- can be used anywhere where a client communicates with an API

## GraphQL vs REST

- Great ideas in REST - stateless servers, structured access to resources
	- REST is a strict spec - but the concept was widely interpreted
	- Rapidly changing client-side requirements don't go well with REST
- GraphQL was developed to cope with the need for more flexibility and efficiency in client-server communication

- REST endpoints will give us a standard templated respose regardless of how much of the info we actually need
- ex
	- /users/\<id>
		- /users/\<id>/posts
		- /users/\<id>/followers
	- each of these endpoints will often give us more info than we actually need for the app logic

- GraphQL: 1 single endpoint for all clients
	- fetch everythin with a single request
	- POST request with a body that includes a query:
		`
		query {
			User(id: "xxxx") {
				name
				posts {
					title
				}
				followers(last: 3) {
					name
				}
			}
		}
		`
		- specify exactly what info you want in a single query


- GraphQL eliminates the problem of over / under fetching
	- **Overfetching**: downloading unnecessary data (this can directly affect user bills)
	- **Underfetching**: An endpoint doesn't return enough of the right info: need to send multiple requests (n+1 requests problem)
- Rapid product iterations
	- REST: structre endpoints according to clients' data needs
		- drawback: doesn't allow for rapid product interations on the front end. Couples the front and back end
	- GraphQL
		- no need to adjust API when product requirements and design change
		- Faster feedback cycles, product iterations
- Insightful Analytics
	- Fine-grained info about what data is read by clients
	- Enables evolving API and deprecating unneeded API features
	- Great opportunities for unstrumenting and performance monitoring
- Benefits of Schema And Types
	- GraphQL uses strong type system to define capabilities of an API
	- Schema serves as contract between client and server
	- Frontend and backend teams can work independently of each other once a contract exists

## Core Concepts
The Schema Definition Language (SDL)
- defining simple types
- exclamation point (!) = required field
`
type Person {
	name: String!
	age: Int!
	posts: [Post!]! <- list
}
`
`
type Post {
	title: String!
	author: Person!
}
`

1 to many relationship between Person <-> Post

Fetching Data with Queries
- REST - each endpoint has a clearly defined structure -> the data requirements of the client are effectively encoded in the url that it is connected to
- GraphQL - only expose a single endpoint
	- structure of data is not fixed - the client decides what is needed
	- client must send more info to server to express what is needed - the Query
`
{
	allPersons {
		name
	}
}
`
- this query returns names of all people in DB
- Can add params to fields (i.e. allPersons(last: 2))

### Writing Data - Mutations
- 3 kinds of mutation
	- creating new data
	- updating existing data
	- deleting existing data

- start with `mutation` keyword
`
mutation {
	createPerson(name: "bob", age: 36) {
		name
		age
	}
}
`

- Can query at the same time as a mutation
- GraphQL types have unique IDs that are generated by the server

Realtime Updates with **Subscriptions**
- when a client subscribes to any event - it will initiate and hold a steady connection to the server
`
subscription {
	newPerson {
		name
		age
	}
}
`
- for each new person created during this subscription, the server will send the corresponding data to the subscribe client

### The GraphQL Schema
- defines the capabilities of the AP and defines how client can fetch and update data
- represents contract between client / server
- collection of GraphQL types with special **root types**

Root Types:
- Query
- Mutation
- Subscription

`
type Query {
	allPersons(last: Int): [Person!]!
	allPosts(last: Int): [Post!]!
}
`

`
type Mutation {
	createPerson(name: String!, age: String!): Person!
	updatePerson(id: ID!, name: String!, age: String!): Person!
	deletePerson(id: ID!): Person!
	createPost(title:String!): Post!
	updatePost(id: ID!, title: String!): Post!
	deletePost(id: ID!): Post!
}
`

`
type Subscription {
	newPerson: Person!
	updatedPerson: Person!
	deletedPerson: Person!
	newPost: Post!
	updatedPost: Post!
	deletedPost: Post!
}
`

## Big Picture / Architecture
- GraphQL is simply a specification - describes the behavior of a GraphQL server

Common use cases
1. GraphQL server with a connected database
2. GraphQL server to integrate existing system
3. A hybrid approach with a connected DB and integration of existing system


### 1. GraphQL server with a connected DB
- often used for greenfiel projects
- uses single web server that implements GraphQL
- server resolves queries and constructs response with data that it fetches from DB


### 2. GraphQL server integrating existing systems
- compelling use for orgs with legacy infrastructure and many diff APIs
- GraphQL can be used to unify existing systems and hide complexy of data fetching logic
- The server doesn't care about what the data sources are (dbs, web services, 3rd party APIs etc)
- integration layer

### 3. Hybrid
- both connected to a DB and integrates with other services / apis


### Resolver functions
- GraphQL queries/mutatations consist of set of fields
- GraphQL server has one resolver function per field
- the purpose of each resolver is to retrieve the data for its corresponding field

### GraphQL Clients
- GraphQL is great for frontend as datafetching complexity can be pushed to the server
- client doesn't care where the data is coming from
- opportunity for new abstractions on the front end
- from imperative to declarative data fetching
	- imperative
		1. construct / send http request
		2. receive / parse server response
		3. store data locally
		4. display data on UI
	- declarative. everything in between 1 and 2 is taken care of by the server
		1. describe data requirements
		2. display info on UI



### Security
Preventing risk:
- timeouts
- query depth limitations
- query complexity limitations
- throttling


---

- GraphQL is a query language for APIs


# Typescript / GraphQL Exercise
- Apollo is a fully-featured GraphQL server based on Express.js
- Nexus is a lib to create type-safe GraphQL schemas with a code-first approach
- Object types vs Scalar types

- Code first approach / Nexus keeps our schema and types in sync for us

The `context` argument is a plain JavaScript object that every resolver in the resolver chain can read from and write to. Thus, it is basically a means for resolvers to communicate. A really helpful feature is that you can already write to the `context` at the moment when the GraphQL server itself is being initialized.